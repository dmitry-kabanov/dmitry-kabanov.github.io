<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Website of Dmitry Kabanov</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="DONE Colaborate in Latex: Overleaf and local git
When you write a paper in \(\LaTeX\) and your collaborators prefer to use Overleaf
but you prefer to use local setup, then you can do it with the help of the git
version control system.
Overall, the process is the following. You create a local git repository and
sync it to a remote git service of your choice.
Then you create a project in Overleaf. In the project settings you can find
the link which you add to your git setup as the second remote server.
The details are below.
Creating the local git setup. This is done the usual way by creating a
project folder and invoking the git init command inside of it.
Add a git remote. After creating a repo in the chosen git cloud service,
you add it to your local git configuration as an origin remote (this name is a
customary name for the primary remote in git).
Creating an Overleaf project. After creating a project in Overleaf, you can
find the git URL in the leftside panel by clicking Menu and then Git in the Sync
subsection. The URL will look like https://git.overleaf.com/ followed by
letters and digits.






Adding the Overleaf git remote. Now you need to add this URL as the second
remote in git:
git remote add overleaf https://git.overleaf.com/random-letters-and-digits
Actual collaboration. The setup process is done and you can syncronize your
origin and overleaf remotes by pulling and pushing to them.
For example, your collaborator tells you that he made changes on the Overleaf
side.
To syncronize these changes to your git cloud, you need to execute these
commands:
git pull overleaf
git push origin
and to push your changes to Overleaf, the command is
git push overleaf
DONE Basic terms in the probability theory
Basic terms in probability theory are outcomes, sample space, events, and
probability measure.
Outcomes and sample space
.
When you conduct a random experiment, there is a set of possible results of this
experiment.
This results are called outcomes.
All possible outcomes together form a set, which is called sample space.">
    <meta name="generator" content="Hugo 0.106.0">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



  
    <link rel="stylesheet" href="/css/chroma.css">
  

    


<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async>
 MathJax.Hub.Config({
     tex2jax: {
         inlineMath: [['$','$'], ['\\(','\\)']],
         displayMath: [['$$','$$'], ['\\[', '\\]']],
         processEscapes: true,
         processEnvironments: true,
         skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
         TeX: { equationNumbers: { autoNumber: "AMS" },
                extensions: ["AMSmath.js", "AMSsymbols.js"] }
     }
 });
 MathJax.Hub.Queue(function() {
     
     
     
     var all = MathJax.Hub.getAllJax(), i;
     for(i = 0; i < all.length; i += 1) {
         all[i].SourceElement().parentNode.className += ' has-jax';
     }
 });

 MathJax.Hub.Config({
     
     TeX: {
         equationNumbers: { autoNumber: "AMS" },
         Macros: {
             C: "{\\mathrm{C}}",
             E: "{\\mathbb{E}}",
             P: "{\\mathbb{P}}",
             R: "{\\mathbb{R}}",
             normal: "{\\mathrm{N}}",
             uniform: "{\\mathrm{Unif}}",
         },
     },
 });
</script>

    
    
      

    

    
    
    <meta property="og:title" content="" />
<meta property="og:description" content="DONE Colaborate in Latex: Overleaf and local git
When you write a paper in \(\LaTeX\) and your collaborators prefer to use Overleaf
but you prefer to use local setup, then you can do it with the help of the git
version control system.
Overall, the process is the following. You create a local git repository and
sync it to a remote git service of your choice.
Then you create a project in Overleaf. In the project settings you can find
the link which you add to your git setup as the second remote server.
The details are below.
Creating the local git setup. This is done the usual way by creating a
project folder and invoking the git init command inside of it.
Add a git remote. After creating a repo in the chosen git cloud service,
you add it to your local git configuration as an origin remote (this name is a
customary name for the primary remote in git).
Creating an Overleaf project. After creating a project in Overleaf, you can
find the git URL in the leftside panel by clicking Menu and then Git in the Sync
subsection. The URL will look like https://git.overleaf.com/ followed by
letters and digits.






Adding the Overleaf git remote. Now you need to add this URL as the second
remote in git:
git remote add overleaf https://git.overleaf.com/random-letters-and-digits
Actual collaboration. The setup process is done and you can syncronize your
origin and overleaf remotes by pulling and pushing to them.
For example, your collaborator tells you that he made changes on the Overleaf
side.
To syncronize these changes to your git cloud, you need to execute these
commands:
git pull overleaf
git push origin
and to push your changes to Overleaf, the command is
git push overleaf
DONE Basic terms in the probability theory
Basic terms in probability theory are outcomes, sample space, events, and
probability measure.
Outcomes and sample space
.
When you conduct a random experiment, there is a set of possible results of this
experiment.
This results are called outcomes.
All possible outcomes together form a set, which is called sample space." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dmitrykabanov.com/blog/2021/2021/" /><meta property="article:section" content="blog" />



<meta itemprop="name" content="">
<meta itemprop="description" content="DONE Colaborate in Latex: Overleaf and local git
When you write a paper in \(\LaTeX\) and your collaborators prefer to use Overleaf
but you prefer to use local setup, then you can do it with the help of the git
version control system.
Overall, the process is the following. You create a local git repository and
sync it to a remote git service of your choice.
Then you create a project in Overleaf. In the project settings you can find
the link which you add to your git setup as the second remote server.
The details are below.
Creating the local git setup. This is done the usual way by creating a
project folder and invoking the git init command inside of it.
Add a git remote. After creating a repo in the chosen git cloud service,
you add it to your local git configuration as an origin remote (this name is a
customary name for the primary remote in git).
Creating an Overleaf project. After creating a project in Overleaf, you can
find the git URL in the leftside panel by clicking Menu and then Git in the Sync
subsection. The URL will look like https://git.overleaf.com/ followed by
letters and digits.






Adding the Overleaf git remote. Now you need to add this URL as the second
remote in git:
git remote add overleaf https://git.overleaf.com/random-letters-and-digits
Actual collaboration. The setup process is done and you can syncronize your
origin and overleaf remotes by pulling and pushing to them.
For example, your collaborator tells you that he made changes on the Overleaf
side.
To syncronize these changes to your git cloud, you need to execute these
commands:
git pull overleaf
git push origin
and to push your changes to Overleaf, the command is
git push overleaf
DONE Basic terms in the probability theory
Basic terms in probability theory are outcomes, sample space, events, and
probability measure.
Outcomes and sample space
.
When you conduct a random experiment, there is a set of possible results of this
experiment.
This results are called outcomes.
All possible outcomes together form a set, which is called sample space.">

<meta itemprop="wordCount" content="2687">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="DONE Colaborate in Latex: Overleaf and local git
When you write a paper in \(\LaTeX\) and your collaborators prefer to use Overleaf
but you prefer to use local setup, then you can do it with the help of the git
version control system.
Overall, the process is the following. You create a local git repository and
sync it to a remote git service of your choice.
Then you create a project in Overleaf. In the project settings you can find
the link which you add to your git setup as the second remote server.
The details are below.
Creating the local git setup. This is done the usual way by creating a
project folder and invoking the git init command inside of it.
Add a git remote. After creating a repo in the chosen git cloud service,
you add it to your local git configuration as an origin remote (this name is a
customary name for the primary remote in git).
Creating an Overleaf project. After creating a project in Overleaf, you can
find the git URL in the leftside panel by clicking Menu and then Git in the Sync
subsection. The URL will look like https://git.overleaf.com/ followed by
letters and digits.






Adding the Overleaf git remote. Now you need to add this URL as the second
remote in git:
git remote add overleaf https://git.overleaf.com/random-letters-and-digits
Actual collaboration. The setup process is done and you can syncronize your
origin and overleaf remotes by pulling and pushing to them.
For example, your collaborator tells you that he made changes on the Overleaf
side.
To syncronize these changes to your git cloud, you need to execute these
commands:
git pull overleaf
git push origin
and to push your changes to Overleaf, the command is
git push overleaf
DONE Basic terms in the probability theory
Basic terms in probability theory are outcomes, sample space, events, and
probability measure.
Outcomes and sample space
.
When you conduct a random experiment, there is a set of possible results of this
experiment.
This results are called outcomes.
All possible outcomes together form a set, which is called sample space."/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Website of Dmitry Kabanov
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/about/" title="About me page">
              About me
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/blog/" title="Blogs page">
              Blogs
            </a>
          </li>
          
        </ul>
      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        BLOGS
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1"></h1>
      
      <p class="tracked">
        By <strong>Dmitry Kabanov</strong>
      </p>
      
      
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h2 id="colaborate-in-latex-overleaf-and-local-git"><!-- raw HTML omitted -->DONE<!-- raw HTML omitted --> Colaborate in Latex: Overleaf and local git</h2>
<p>When you write a paper in \(\LaTeX\) and your collaborators prefer to use <a href="https://www.overleaf.com">Overleaf</a>
but you prefer to use local setup, then you can do it with the help of the <a href="https://git-scm.com/">git
version control system</a>.</p>
<p>Overall, the process is the following. You create a local git repository and
sync it to a remote git service of your choice.
Then you create a project in Overleaf. In the project settings you can find
the link which you add to your git setup as the second remote server.
The details are below.</p>
<p><strong>Creating the local git setup.</strong> This is done the usual way by creating a
project folder and invoking the <code>git init</code> command inside of it.</p>
<p><strong>Add a git remote.</strong> After creating a repo in the chosen git cloud service,
you add it to your local git configuration as an <em>origin</em> remote (this name is a
customary name for the primary remote in git).</p>
<p><strong>Creating an Overleaf project.</strong> After creating a project in Overleaf, you can
find the git URL in the leftside panel by clicking Menu and then Git in the Sync
subsection. The URL will look like <code>https://git.overleaf.com/</code> followed by
letters and digits.</p>
<figure><img src="/images/2021/collaborate-latex-git-1.png"/>
</figure>

<figure><img src="/images/2021/collaborate-latex-git-2.png"/>
</figure>

<p><strong>Adding the Overleaf git remote.</strong> Now you need to add this URL as the second
remote in git:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">git remote add overleaf https://git.overleaf.com/random-letters-and-digits
</span></span></code></pre></div><p><strong>Actual collaboration.</strong> The setup process is done and you can syncronize your
<code>origin</code> and <code>overleaf</code> remotes by pulling and pushing to them.
For example, your collaborator tells you that he made changes on the Overleaf
side.
To syncronize these changes to your git cloud, you need to execute these
commands:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">git pull overleaf
</span></span><span class="line"><span class="cl">git push origin
</span></span></code></pre></div><p>and to push your changes to Overleaf, the command is</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">git push overleaf
</span></span></code></pre></div><h2 id="basic-terms-in-the-probability-theory"><!-- raw HTML omitted -->DONE<!-- raw HTML omitted --> Basic terms in the probability theory</h2>
<p>Basic terms in probability theory are outcomes, sample space, events, and
probability measure.</p>
<p><strong>Outcomes and sample space</strong>
.
When you conduct a random experiment, there is a set of possible results of this
experiment.
This results are called <em>outcomes</em>.
All possible outcomes together form a set, which is called <em>sample space</em>.</p>
<p>It is customary to denote outcomes with \(\omega\) and sample space with \(\Omega\):
\[
\Omega = \{
\omega \text{ such that } \omega \text{ is an outcome of random experiment}
\}.
\]</p>
<p><strong>Events and events space</strong>.
Subsets of the sample space \(\Omega\) are called <em>events</em>.
We collect events which are interesting for us in another set
\(\mathcal F\), that is, \(\mathcal F\) is a set of subsets of \(\Omega\).
Note that the set \(\mathcal F\) must contain not only events we are interested in
but also unions and intersections of all of them.
Besides, if an event is in \(\mathcal F\), the complement of this event must be
also in \(\mathcal F\).
Sets such as \(\mathcal F\) are called
<a href="/blog/2019/borel-sigma-algebra">$σ$-algebras</a>.</p>
<p><strong>Important</strong>. Note that \(\omega\) is an outcome, while
\(\{\omega\}\) is a possible event.</p>
<p><strong>Probability measure</strong>.
Finally, each event can be measured with a number from zero to unity.
Function that takes as input an event and returns number from zero to unity, is
called <em>probability measure</em>, or just simply probability.
In general, <a href="https://en.wikipedia.org/wiki/Measure"><em>measure</em></a> in mathematics is a function that takes a set and returns
its size as a nonnegative number.</p>
<p><strong>Probability space</strong>.
Three quantities&mdash;sample space, $σ$-algebra of events, probablity measure&mdash;
form a <em>triplet</em> called <em>probability space</em>:
\[
(\Omega, \mathcal F, \P).
\]</p>
<h2 id="books-on-writing-science"><!-- raw HTML omitted -->DONE<!-- raw HTML omitted --> Books on writing science</h2>
<p>To be successful in academia, it is very important to have a good skill in
writing and to write often and productively.
Because the good skill in writing is rarely taught, one should learn it from
reading books on the topic.</p>
<p>Recommended books on this topic are:</p>
<ul>
<li>
<p>Belcher W. <em>Writing Your Journal Article in Twelve Weeks</em>, Second Edition</p>
<p>I haven&rsquo;t read it but it has very high grades in reviews.
The book is in Letter paper size and has 427 pages, so, I guess, it is worth
considering buying an e-book version on the <a href="https://press.uchicago.edu/ucp/books/book/chicago/W/bo26985005.html">publisher&rsquo;s website</a>.</p>
</li>
<li>
<p>Schimel J. <em>Writing Science: How to Write Papers That Get Cited and Proposals
That Get Funded</em></p>
<p>This book I have partially read in 2020.
It is a wonderful book that explains how to write such that there is a story
and there are characters acting in this story.</p>
</li>
</ul>
<h2 id="need-for-software-testing"><!-- raw HTML omitted -->DONE<!-- raw HTML omitted --> Need for software testing</h2>
<p>Recently I was attending the class on uncertainty quantification for partial
differential equations.
As a postdoc, I do participate in the class only partially, however, I have a
group of students that I am helping with the homework.</p>
<p>The first homework required use of Monte Carlo methods with differential
equations with random coefficients to estimate uncertainty in the solutions of
these equations.
As the person with experience in writing PDE solvers, I wrote the solver for the
PDE that we used in this homework and shared it with others.
Of course, after writing a solver, I wrote a test that the observed order of
accuracy is correct (second order, in this case) as I strongly believe that the
automated testing is superimportant in software and the test on the observed
order of accuracy is the best test for numerical solvers.</p>
<p>So, after writing the solver, I was sure that it worked correctly, and we
started to do Monte Carlo exercises with this solver.
It quickly turned out that we get some unexpected results.
Particularly, I was doing an exercise on rare-event simulation, however, the
event proposed in the exercise was not rare at all!
I&rsquo;ve spent some time trying to understand what could be wrong with my
importance-sampling Monte Carlo that I used for this rare-event simulation
but could not find any bugs.
I did not think that the problem could be with the PDE solver as I was sure it
worked correctly: I had a test that shows that the order of convergence is
correct, hence, there could not be any problem.</p>
<p>However, another student, who used my solver, told me that while estimating the
convergence rate of the bias error, she did not get an expected second rate but
only the first rate.
That finally made me convinced that the problem is with the PDE solver as the
convergence rate of the bias error directly depends on the convergence rate of
the PDE solver.</p>
<p>After two-hour investigation, with looking at the solver function and not seeing
any apparent mistakes, I have realized that the problem is that my test
suite for the PDE solver is too weak.
Indeed, having a single test that check convergence only for a particular PDE
with constant coefficients is not enough to ensure correctness of the solver.</p>
<p>The solver solves an equation of the elliptic type:</p>
<p>\begin{aligned}
\mathrm{div} \left( a(x, \omega) \, \nabla u(x, \omega) \right) &amp;= f(x),
\quad x \in D, \\
u(x \in \partial D) &amp;= 0,
\end{aligned}</p>
<p>where the source term \(f(x)\) was given, so I hardcoded it into the solver
function.</p>
<p>As it was clear now that I need a test with coefficient \(a(x, \omega)\) being
nonconstant, I used the
<a href="https://www.osti.gov/biblio/759450/">method of manufactured solutions</a>
to develop this more stringent test.
Precisely, I chose the form of the coefficient \(a(x, \omega)\) and the solution
\(u(x, \omega)\) and then found the needed source term \(f(x)\) by substituting into
the equation.
Consequently, the solver function was generalized by adding an argument for the
callback of the source term.</p>
<p>After adding this test, it was clear that the solver does not give the correct
order of convergence: it was one instead of two!
Now, having the test, I started to analyze the solver again.
As the problem occurred only with the variable coefficient and not with the
constant one, it was clear that there is some problem with the construction of
the matrix \(A\) as elliptic equations are solved numerically by building the
system of linear algebraic equations:
\[
A u = f,
\]
where \(u\) and \(f\) are functions discretized on the grid.</p>
<p>Usually, the matrix \(A\) is a sparse matrix, and I used the function
<code>scipy.sparse.spdiags</code> to build it.
What I haven&rsquo;t realized initially, why programming the solver, that this
function has some unintuitive behavior when constructing upper diagonals.</p>
<p>Precisely, if you have the following vectors to build the tridiagonal matrix:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">  <span class="n">e1</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="n">e2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="n">e3</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">]</span>
</span></span></code></pre></div><p>then the call to <code>spdiags</code> produces the following results</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">  <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">sparse</span>
</span></span><span class="line"><span class="cl">  <span class="nb">print</span><span class="p">(</span><span class="n">sparse</span><span class="o">.</span><span class="n">spdiags</span><span class="p">([</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">e3</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">todense</span><span class="p">())</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">[[10  2  0  0]
</span></span><span class="line"><span class="cl"> [-1 20  3  0]
</span></span><span class="line"><span class="cl"> [ 0 -2 30  4]
</span></span><span class="line"><span class="cl"> [ 0  0 -3 40]]
</span></span></code></pre></div><p>Note that the first value of the upper-diagonal vector is not used!</p>
<p>Fortunately, <code>scipy</code> provides another function, <code>diags</code>, which has more
intuitive behavior.
The call to <code>diags</code> produces the expected result:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">  <span class="nb">print</span><span class="p">(</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">([</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">e3</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="n">todense</span><span class="p">())</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">[[10.  1.  0.  0.]
</span></span><span class="line"><span class="cl"> [-1. 20.  2.  0.]
</span></span><span class="line"><span class="cl"> [ 0. -2. 30.  3.]
</span></span><span class="line"><span class="cl"> [ 0.  0. -3. 40.]]
</span></span></code></pre></div><p>After changing from <code>spdiags</code> to <code>diags</code>, the PDE solver started to work
correctly and passed both tests: for constant and variable coefficients.
We were able to use it for Monte Carlo simulations and finish the homework.</p>
<p>The point of this post is that when one needs to work on the multicomponent code
like in this case (Monte Carlo simulator plus PDE solver), it is crucial to test
the individual components of the code independently.
Moreover, it is crucial to write good tests: if tests are too “easy”, they
give a false feeling of safety.
Only when tests are strict enough, one can be sure that different software
components work correctly and can be used together to solve a computational task.</p>
<h2 id="how-to-quickly-insert-a-figure-in-lyx"><!-- raw HTML omitted -->DONE<!-- raw HTML omitted --> How to quickly insert a figure in LyX</h2>
<p>I will show one of the user-defined commands that I use in
<a href="https://lyx.org">Lyx</a>, a \(\LaTeX\) frontend, to quickly insert figures with
captions.</p>
<!-- raw HTML omitted -->
<p>Lyx is a wonderful software that makes it easier to
typeset documents that are usually produced with \(\LaTeX\).
Instead of seeing only \(\LaTeX\) source code, you can see approximately what
the final document will look like.
Particularly, the typesetting of mathematical formulas is much easier, as you
can see their rendered form immediately.
I used Lyx a lot during my PhD years, and I still use it often
for private writing, such as small mathematical notes or laboratory
notebooks.</p>
<p>When you use some software extensively, you do some operations very frequently.
One of such operations is to insert figures.
The procedure is the following:</p>
<ol>
<li>You press the <code>Insert float</code> toolbar button or the corresponding menu command.</li>
<li>Then you need to remove the end-of-paragraph symbol after the caption
placeholder. (I am not quite sure why it is there.)</li>
<li>Move the cursor to the paragraph up, where the figure will be inserted.</li>
<li>Open <code>Paragraph settings</code> dialog window.</li>
<li>Set property <code>Centered</code>.</li>
<li>Close the dialog window.</li>
<li>Open the dialog window for the figure using the <code>Insert graphics</code> toolbar
button or the corresponding menu item.</li>
</ol>
<p>Only after these generic actions, you start to do something unique, like
choosing the actual graphics file you want to insert or typing the figure
caption.</p>
<p>To make the process simpler, it is helpful to introduce a new command that will
do the above actions for you and assign a keyboard shortcut for this
command.
The process is the following.</p>
<ol>
<li>
<p>Open Lyx Preferences (it depends on the operating system that you use).</p>
</li>
<li>
<p>Click the <code>New</code> button.</p>
</li>
<li>
<p>In the opened <code>Edit shortcut</code> window, insert the following line in the
<code>Function</code> field:</p>
<p><code>command-sequence float-insert figure; char-right; char-delete-forward; up; paragraph-params \align center; dialog-show-new-inset graphics;</code></p>
</li>
<li>
<p>In the <code>Shortcut</code> field, choose your shortcut (my preference is
<code>Ctrl-Shift-F</code>).</p>
</li>
<li>
<p>Press <code>OK</code>.</p>
</li>
</ol>
<p>That&rsquo;s it!
Now it will be much easier to insert new figures in Lyx documents.
By pressing the chosen shortcut, you are immediately taken to the dialog window
for selecting a graphic file, and after selecting it, you have it centered.
The only thing left is to type the corresponding figure caption.</p>
<h2 id="stochastic-processes-of-brownian-motion-type"><!-- raw HTML omitted -->TODO<!-- raw HTML omitted --> Stochastic processes of brownian motion type</h2>
<p>In this post, I consider several stochastic processes of Brownian motion
type&mdash;precisely, standard Brownian motion, Brownian motion with drift, and
geometric Brownian motion.</p>
<p>First, let&rsquo;s import important packages and set constant and random seed:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Set random seed for reproducibility.</span>
</span></span><span class="line"><span class="cl"><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Time step.</span>
</span></span><span class="line"><span class="cl"><span class="n">DELTA_T</span> <span class="o">=</span> <span class="mf">0.1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Number of time steps.</span>
</span></span><span class="line"><span class="cl"><span class="n">NTIMES</span> <span class="o">=</span> <span class="mi">1000</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Number of sample paths.</span>
</span></span><span class="line"><span class="cl"><span class="n">NPATHS</span> <span class="o">=</span> <span class="mi">10</span>
</span></span></code></pre></div><h3 id="standard-brownian-motion">Standard Brownian motion</h3>
<p>This process has the property that the increments are independent and normally
distributed with zero mean and variance equal to the time between increments.
It is also known as Wiener process. Formally, definition is</p>
<p>A stochastic process \(B(t)\), \(t\ge0\) is called
standard Brownian Motion (BM), if</p>
<ol>
<li>\(B(0) = 0\).</li>
<li>\(B(t)\) has stationary and independent increments.</li>
<li>Increments \(B(t) - B(s)\) are random variables with distribution \(N(0, t-s)\).</li>
</ol>
<p>Because the increments are independent, it follows that \(B(s)\) is independent
from \(B(t)-B(s)\) (because \(B(s)\) can be seen as an increment \(B(s)-B(0)\).
\[
B(t) = B(s) + \left( B(t) - B(s) \right)
\]
The above formula gives us the way to simulate the process.
To simulate it at times \(0 = t_0 &lt; t_1 &lt; \dots &lt; t_k\):</p>
<ol>
<li>Simulate \(k\) independent standard normal variables \(Z_i\), \(i=1,\dots,k\).</li>
<li>Set \(B(0) = 0\).</li>
<li>Set \(B(t_k) = \sum_{i=1}^k \sqrt{\Delta t_i} Z_i\), where \(\Delta t_i = t_i - t_{i-1}\).</li>
</ol>
<p>Python code to simulate one single realization (sample path):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">generate_standard_brownian_motion</span><span class="p">(</span><span class="n">delta_t</span><span class="p">,</span> <span class="n">nT</span><span class="p">,</span> <span class="n">s0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;Generate realization of standard motion process.
</span></span></span><span class="line"><span class="cl"><span class="s2">
</span></span></span><span class="line"><span class="cl"><span class="s2">    Parameters
</span></span></span><span class="line"><span class="cl"><span class="s2">    ----------
</span></span></span><span class="line"><span class="cl"><span class="s2">    delta_t : float
</span></span></span><span class="line"><span class="cl"><span class="s2">        Time step size.
</span></span></span><span class="line"><span class="cl"><span class="s2">    nT : int
</span></span></span><span class="line"><span class="cl"><span class="s2">        Number of time steps.
</span></span></span><span class="line"><span class="cl"><span class="s2">
</span></span></span><span class="line"><span class="cl"><span class="s2">    Returns
</span></span></span><span class="line"><span class="cl"><span class="s2">    -------
</span></span></span><span class="line"><span class="cl"><span class="s2">    s : ndarray(nT+1,)
</span></span></span><span class="line"><span class="cl"><span class="s2">        Realization (sample path) of the stochastic process.
</span></span></span><span class="line"><span class="cl"><span class="s2">        Note that the initial zero value is included.
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">deltaW</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">delta_t</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">nT</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nT</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span>  <span class="n">s0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">deltaW</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="n">nT</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">s</span>
</span></span></code></pre></div><p>Then, to simulate the multiple paths, we just call this function several times:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">sbm_paths</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">__</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NPATHS</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">sbm_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">generate_standard_brownian_motion</span><span class="p">(</span><span class="n">DELTA_T</span><span class="p">,</span> <span class="n">NTIMES</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NPATHS</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sbm_paths</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span> <span class="n">sbm_paths</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&#34;Time&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&#34;Process realization&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&#34;Standard brownian motion&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s2">&#34;sbm.pdf&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="s2">&#34;sbm.pdf&#34;</span>
</span></span></code></pre></div><p>&lt;&gt;</p>
<h2 id="measure-performance-in-python-using-time-dot-perf-counter"><!-- raw HTML omitted -->TODO<!-- raw HTML omitted --> Measure performance in Python using time.perf_counter</h2>
<h2 id="how-to-use-anki-for-learning-irregular-verbs-in-german"><!-- raw HTML omitted -->TODO<!-- raw HTML omitted --> How to use Anki for learning irregular verbs in German</h2>
<h2 id="use-tf-dot-shape-to-get-dynamic-tensor-shape"><!-- raw HTML omitted -->TODO<!-- raw HTML omitted --> Use tf.shape to get dynamic tensor shape</h2>
<p>\[
E = mc^2
\]</p>
<p>Using Eq. (1), we arrive at</p>
<p>\begin{equation}
y = x^2,
\end{equation}</p>
<p>where we should use</p>
<p>\begin{equation*}
y = \int_\alpha^\beta x \, dx.
\end{equation*}</p>
<h2 id="why-rescale-features-in-regression"><!-- raw HTML omitted -->TODO<!-- raw HTML omitted --> Why rescale features in regression</h2>
<h2 id="linear-regression-do-not-put-free-term-in-the-l2-regularization"><!-- raw HTML omitted -->TODO<!-- raw HTML omitted --> Linear regression - do not put free term in the L2 regularization</h2>
<p>See <a href="https://dyakonov.org/2019/10/31/%d0%bb%d0%b8%d0%bd%d0%b5%d0%b9%d0%bd%d0%b0%d1%8f-%d1%80%d0%b5%d0%b3%d1%80%d0%b5%d1%81%d1%81%d0%b8%d1%8f/">https://dyakonov.org/2019/10/31/%d0%bb%d0%b8%d0%bd%d0%b5%d0%b9%d0%bd%d0%b0%d1%8f-%d1%80%d0%b5%d0%b3%d1%80%d0%b5%d1%81%d1%81%d0%b8%d1%8f/</a></p>
<h2 id="using-numba-to-speedup-scientific-computations"><!-- raw HTML omitted -->TODO<!-- raw HTML omitted --> Using Numba to speedup scientific computations</h2>
<p>Recently I was helping a student to speed up her code for solving a PDE.
The code was written in Python and we decided to use
<a href="https://numba.pydata.org/">Numba</a> optimizing compiler to optimize the code.
The optimization results were wonderful: we obtained 170x speedup!
Previously, I experimented with Numba for short time in 2015 but never actually
used it deeply.
This experience made me think that probably it is a good idea nowadays first to
try optimizing code with Numba before attempting to use something like
<a href="https://cython.org">Cython</a>.</p>
<p>Below I want to give a small example on how to use Numba.</p>
<p>Let assume that we have a function like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">time</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">compute_v1</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">      <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">c</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">1000000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">1000000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">compute_v1</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;v1 time: </span><span class="si">{:.6f}</span><span class="s2"> sec&#34;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">v1 time: 0.897440 sec
</span></span></code></pre></div><h2 id="how-to-obtain-shape-of-a-tensor-in-tf-dot-function-decorated-function"><!-- raw HTML omitted -->TODO<!-- raw HTML omitted --> How to obtain shape of a tensor in tf.function-decorated function</h2>
<p>Somehow, you cannot obtain the shape of the dynamic tensor.</p>
<h2 id="introduction-to-kalman-filters"><!-- raw HTML omitted -->TODO<!-- raw HTML omitted --> Introduction to Kalman filters</h2>
<p>A Kalman filter is an iterative mathematical process that uses a set of
equations (describing some physical process) and consecutive data inputs to
estimate some quantities when the measurements contain uncertainties or
errors.</p>
<p>Each iteration consists of three steps:</p>
<ol>
<li>Kalman gain computation. Improved estimate based on measurements and model
prediction.</li>
<li>Current state estimation.</li>
<li>Error computation.</li>
</ol>
<p>Kalman filter has an assumption that the noise in measurements has Gaussian
distribution.
This assumption is quite natural and works well in many situations.</p>
<p>If you cannot make this assumption about the noise, then Particle Filtering
will work better.</p><ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="ssssss bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://dmitrykabanov.com/" >
    &copy;  Website of Dmitry Kabanov 2022 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
